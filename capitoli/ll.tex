\section{Tabella di parsing}
\label{sec:parser-sll}

In questa sezione vedremo un metodo deterministico per il parsing top-down, in grado di costruire sempre lo stesso
albero di derivazione.
Mentre la discesa ricorsiva potrebbe, nel caso peggiore, generare un numero esponenziale di alberi parziali, un parsing
deterministico non ammette più di una possibile estensione ad ogni passo.
L'efficienza pratica della discesa ricorsiva è dovuta al fatto che ogni produzione il cui membro destro inizia con un
terminale $c$ può essere applicata solo se il carattere attuale dell'input è uguale a $c$: ciò permette di non applicare
alcune produzioni.

Il fatto di considerare solo parsing deterministici ha una conseguenza importante: non saremo più in grado di analizzare
una generica grammatica libera dal contesto, ma solo un insieme ristretto.
Ad esempio, non potremo gestire grammatiche ambigue.

Iniziamo con un caso particolarmente ristretto: tutte le produzioni hanno un membro destro che inizia con un terminale.
Se permettiamo di espandere solo produzioni il cui membro sinistro inizia con il simbolo attuale dell'input, limitiamo
fortemente l'insieme delle possibili scelte, riducendo i tempi di calcolo.

Se desideriamo aumentare ulteriormente l'efficienza del parsing, possiamo calcolare una tabella, chiamata
\keyword{tabella di parsing}, che associa ad ogni coppia variable-terminale le produzioni che hanno tale variabile come
membro destro e il cui membro sinistro inizia con il terminale.

Notiamo che la tabella di parsing è sufficiente per determinare tutto il parsing, perchè l'algoritmo semplicemente
guarderà il carattere attuale dell'input per determinare quali produzioni siano applicabili.
Possiamo restringere ulteriormente l'insieme delle grammatiche che siamo in grado di gestire, richiedendo che nessuna
cella della tabella di parsing contenga più di una produzione: ciò corrisponde alle grammatiche \keyword{SLL(1)}, anche
dette grammatiche LL(1) semplici, dove la prima L indica che il parser produrrà un'albero di derivazione sinistro
(leftmost), mentre L(1) indica che il parser potrà vedere un carattere a destra di quello attuale.

\section{Parser LL(1)}
\label{sec:parser-ll}

Procediamo gradualmente verso la rimozione dei principali vincoli, iniziamo non permettendo $\varepsilon$-produzioni.
Ciò implica che ogni variabile produce solo stringhe non vuote.
Per costruire la tabella di parsing, per ogni variabile $A$ costruiamo l'insieme $\First(A)$ che contiene i terminali
$c$ tali che $A \eprod{} t\alpha$, ovvero i terminali che iniziano una forma sentenziale che può essere prodotta a partire
da $A$.
Una volta costruiti tutti gli insiemi $\First(\cdot)$, possiamo costruire la tabella di parsing $TP$ con
l'\Cref{alg:costruzione-tabella-parsing-da-first}, dove assumiamo di conoscere $\First(\alpha)$ per ogni forma
sentenziale $\alpha$.
Ciò non è una vera limitazione, in quanto dobbiamo solo considerare il primo simbolo di $\alpha$: se si tratta di una
variabile $A$, sarà memorizzata nella tabella $\First{A}$.
Altrimenti il primo simbolo di $\alpha$ è un terminale $c$ e in questo caso possiamo imporre $\First(c) = \{c\}$.
Inoltre la tabella $TP$ deve contenere solo il membro destro della produzione, in quanto il membro sinistro è la
variabile $A$.

L'\Cref{alg:costruzione-tabella-parsing-da-first} è un esempio di algoritmo che costruisce il risultato per
  accumulazione (cioè aggiungendo qualcosa, senza mai togliere) e prosegue finchè non si raggiunge un punto fisso,
  ovvero un valore del risultato per cui non vengono più effettuate aggiunte.
La terminazione di questa procedura deriva dal fatto che ad ogni iterazione (tranne l'ultima) deve necessariamente
essere aggiunto almeno un elemento al risultato, e il risultato è un sottoinsieme di un insieme finito.
In questo caso, ogni $TP[\cdot]$ è un sottoinsieme di tutte le produzioni della grammatica.



\begin{algorithm}[tb!]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\caption{Costruzione della tabella di parsing $TP$ in assenza di \epsprod}
\label{alg:costruzione-tabella-parsing-da-first}
\tcp{$c$ è un terminale, $A$ è una variabile}
\ForEach{$A\in V, c\in T$}{$TP[A,c]=\emptyset$}
\ForEach{produzione $A\to \alpha V$}{%
  \eIf{$\alpha$ inizia con il terminale $c$}{%
    Aggiungiamo $\alpha$ all'insieme $TP[A,c]$
  }{\ForEach{$c\in\First(\alpha)$}{%
      Aggiungiamo $\alpha$ all'insieme $TP[A,c]$
    }
  }
  }
\Return $TP$
\end{algorithm}


Rimane da descrivere come costruire gli insiemi $\First$.
Assumiamo inizialmente di non avere $\varepsilon$-produzioni: ciò implica che $\First(A)$ sarà uguale all'unione di
$\First(\alpha_{i})$ per tutte i membri destri delle produzioni che hanno $A$ come membro sinistro.
In altre parole, se $A\to \alpha_{1},\ldots, \alpha_{n}$ sono tutte le produzioni che hanno $A$ come membro sinistro,
allora $\First(A) = \bigcup_{i} \First(\alpha_{i})$.
Notiamo però che ogni $\alpha_{i}$ è una forma sentenziale, pertanto dobbiamo capire come calcolare $\First(\alpha_{i})$.
Siccome supponiamo di non avere \epsprod, per ogni forma sentenziale $\alpha_{i}$ è sufficente considerare la sua prima
variabile o il suo primo terminale.
Quindi, se $\alpha_{i}=x\beta_{i}$ con $x\in V\cup T$, allora $\First(\alpha_{i}) = \First(x)$, arrivando
all'\Cref{alg:costruzione-first-no-eps-produzioni}, dove $\First$ viene costruito incrementalmente, finchè non si arriva
ad un punto fisso.


\begin{algorithm}[tb!]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\caption{Costruzione di $\First$ in assenza di \epsprod}
\label{alg:costruzione-first-no-eps-produzioni}
\tcp{$c$ è un terminale, $A$ è una variabile, $\alpha$ è una forma sentenziale}
$\First[\varepsilon]=\{\varepsilon\}$\;
\ForEach{$c\in T$}{$\First[c]=\{c\}$}
\ForEach{$A\in V$}{$\First[A]=\emptyset$}
$m\gets$ vero\;
\While{$m$}{%
    $m \gets $ falso\;
    \ForEach{produzione $A\to c\alpha$}{%
      \If{$\First[c] \not\subseteq \First[A]$}{
        Aggiungiamo $\First[c]$ all'insieme $\First[A]$\;
        $m\gets$ vero\;
        }
      }
    }
\Return $\First$
\end{algorithm}

Purtroppo non possiamo escludere la presenza di \epsprod.
In particolare, consideriamo cosa succede se vogliamo calcolare $\First(A\alpha)$, dove $A$ è una variabile e $\alpha$
un forma sentenziale, quanto $A\eprod{} \varepsilon$.
In questo caso $\First(A\alpha)$ include non solo $\First(A)$, ma anche $\First(\alpha)$, perchè se
$A\eprod{} \varepsilon$ allora il primo carattere generato da $A\alpha$ potrebbe essere il primo carattere generato da $\alpha$.
Non possiamo però dire che $\First(A\alpha) = \First(A) \cup \First(\alpha)$, perchè non possiamo escludere che anche
$\alpha \eprod{} \varepsilon$.
Per questo motivo introduciamo $\Follow(A)$ che è l'insieme dei terminali che seguono immediatamente la derivazione di $A$.

\begin{algorithm}[tb!]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\caption{Costruzione di $\Follow$}
\label{alg:costruzione-follow}
\tcp{$A, B$ sono variabili, $\alpha, \beta$ sono forme sentenziali}
\ForEach{$A\in V$}{$\Follow[A]=\emptyset$}
$m\gets$ vero\;
\While{$m$}{%
    $m \gets $ falso\;
    \ForEach{produzione $A\to \alpha B\beta$}{%
      \If{$\First[\beta] \not\subseteq \Follow[B]$}{
        Aggiungiamo $\First[\beta]$ all'insieme $\Follow[B]$\;
        $m\gets$ vero\;
        }
        \If{$\beta \eprod{} \varepsilon$ e $\Follow[A] \not\subseteq \Follow[B]$}{%
          Aggiungiamo $\Follow[A]$ all'insieme $\Follow[B]$\;
          $m\gets$ vero\;
        }
      }
    }
\Return $\Follow$
\end{algorithm}

Dobbiamo adesso aggiornare la procedura per calcolare la tabella $TP$, dove ogni produzione $A\to \alpha$ viene
considerata e, se $\alpha$ non inizia con un terminale, allora aggiungiamo $\alpha$ all'insieme $TP[A,c]$ per ogni
terminale $c\in \First(\alpha)$ (esattamente come in \Cref{alg:costruzione-tabella-parsing-da-first}) e per ogni
terminale in $\Follow(A)$, se $\alpha$ può produrre la stringa vuota $\varepsilon$.
Queste operazioni vengono riassunte con i terminali nell'insieme $\First(\alpha\Follow(A))$: infatti se $\alpha$ non può
generare la stringa vuota, allora $\First(\alpha\Follow(A)) = \First(\alpha)$.



\begin{algorithm}[tb!]
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\caption{Costruzione della tabella di parsing $TP$}
\label{alg:costruzione-tabella-parsing-da-first-follow}
\tcp{$c$ è un terminale, $A$ è una variabile}
\ForEach{$A\in V, c\in T$}{$TP[A,c]=\emptyset$}
\ForEach{produzione $A\to \alpha$}{%
  \eIf{$\alpha$ inizia con il terminale $c$}{%
    Aggiungiamo $\alpha$ all'insieme $TP[A,c]$
  }{\ForEach{$c\in\First(\alpha\Follow(A))$}{%
      Aggiungiamo $\alpha$ all'insieme $TP[A,c]$
    }
  }
  }
\Return $TP$
\end{algorithm}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../libro-linguaggi"
%%% TeX-engine: luatex
%%% End:
